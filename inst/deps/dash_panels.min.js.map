{"version":3,"file":"dash_panels.min.js","mappings":"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","sources":["webpack:///webpack/runtime/create fake namespace object","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///webpack/runtime/compat","webpack:///external window \"PropTypes\"","webpack:///external window \"React\"","webpack:///./node_modules/react-resizable-panels/dist/react-resizable-panels.browser.js","webpack:///./src/lib/components/Panel.react.js","webpack:///./src/lib/components/PanelGroup.react.js","webpack:///./src/lib/components/PanelResizeHandle.react.js"],"sourcesContent":["var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var getCurrentScript = function() {\n    var script = document.currentScript;\n    if (!script) {\n        /* Shim for IE11 and below */\n        /* Do not take into account async scripts and inline scripts */\n\n        var doc_scripts = document.getElementsByTagName('script');\n        var scripts = [];\n\n        for (var i = 0; i < doc_scripts.length; i++) {\n            scripts.push(doc_scripts[i]);\n        }\n\n        scripts = scripts.filter(function(s) { return !s.async && !s.text && !s.textContent; });\n        script = scripts.slice(-1)[0];\n    }\n\n    return script;\n};\n\nvar isLocalScript = function(script) {\n    return /\\/_dash-component-suites\\//.test(script.src);\n};\n\nObject.defineProperty(__webpack_require__, 'p', {\n    get: (function () {\n        var script = getCurrentScript();\n\n        var url = script.src.split('/').slice(0, -1).join('/') + '/';\n\n        return function() {\n            return url;\n        };\n    })()\n});\n\nif (typeof jsonpScriptSrc !== 'undefined') {\n    var __jsonpScriptSrc__ = jsonpScriptSrc;\n    jsonpScriptSrc = function(chunkId) {\n        var script = getCurrentScript();\n        var isLocal = isLocalScript(script);\n\n        var src = __jsonpScriptSrc__(chunkId);\n\n        if(!isLocal) {\n            return src;\n        }\n\n        var srcFragments = src.split('/');\n        var fileFragments = srcFragments.slice(-1)[0].split('.');\n\n        fileFragments.splice(1, 0, \"v0_0_1m1758736302\");\n        srcFragments.splice(-1, 1, fileFragments.join('.'))\n\n        return srcFragments.join('/');\n    };\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"PropTypes\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"React\"];","import * as React from 'react';\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\n\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst DATA_ATTRIBUTES = {\n  group: \"data-panel-group\",\n  groupDirection: \"data-panel-group-direction\",\n  groupId: \"data-panel-group-id\",\n  panel: \"data-panel\",\n  panelCollapsible: \"data-panel-collapsible\",\n  panelId: \"data-panel-id\",\n  panelSize: \"data-panel-size\",\n  resizeHandle: \"data-resize-handle\",\n  resizeHandleActive: \"data-resize-handle-active\",\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\n  resizeHandleId: \"data-panel-resize-handle-id\",\n  resizeHandleState: \"data-resize-handle-state\"\n};\nconst PRECISION = 10;\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst useId = React[\"useId\".toString()];\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSize,\n  collapsible,\n  defaultSize,\n  forwardedRef,\n  id: idFromProps,\n  maxSize,\n  minSize,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    reevaluatePanelConstraints,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSize,\n      collapsible,\n      defaultSize,\n      maxSize,\n      minSize\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    const prevConstraints = {\n      ...constraints\n    };\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSize = collapsedSize;\n    constraints.collapsible = collapsible;\n    constraints.defaultSize = defaultSize;\n    constraints.maxSize = maxSize;\n    constraints.minSize = minSize;\n\n    // If constraints have changed, we should revisit panel sizes.\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\n    }\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: minSize => {\n      expandPanel(panelDataRef.current, minSize);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: size => {\n      resizePanel(panelDataRef.current, size);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: panelId,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.panel]: \"\",\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\n    [DATA_ATTRIBUTES.panelId]: panelId,\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nlet nonce;\nfunction getNonce() {\n  return nonce;\n}\nfunction setNonce(value) {\n  nonce = value;\n}\n\nlet currentCursorStyle = null;\nlet enabled = true;\nlet getCustomCursorStyleFunction = null;\nlet prevRuleIndex = -1;\nlet styleElement = null;\nfunction customizeGlobalCursorStyles(callback) {\n  getCustomCursorStyleFunction = callback;\n}\nfunction disableGlobalCursorStyles() {\n  enabled = false;\n}\nfunction enableGlobalCursorStyles() {\n  enabled = true;\n}\nfunction getCursorStyle(state, constraintFlags, isPointerDown) {\n  const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\n  const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\n  const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\n  const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\n  if (getCustomCursorStyleFunction) {\n    return getCustomCursorStyleFunction({\n      exceedsHorizontalMaximum: horizontalMax,\n      exceedsHorizontalMinimum: horizontalMin,\n      exceedsVerticalMaximum: verticalMax,\n      exceedsVerticalMinimum: verticalMin,\n      intersectsHorizontalDragHandle: state === \"horizontal\" || state === \"intersection\",\n      intersectsVerticalDragHandle: state === \"vertical\" || state === \"intersection\",\n      isPointerDown\n    });\n  }\n  if (constraintFlags) {\n    if (horizontalMin) {\n      if (verticalMin) {\n        return \"se-resize\";\n      } else if (verticalMax) {\n        return \"ne-resize\";\n      } else {\n        return \"e-resize\";\n      }\n    } else if (horizontalMax) {\n      if (verticalMin) {\n        return \"sw-resize\";\n      } else if (verticalMax) {\n        return \"nw-resize\";\n      } else {\n        return \"w-resize\";\n      }\n    } else if (verticalMin) {\n      return \"s-resize\";\n    } else if (verticalMax) {\n      return \"n-resize\";\n    }\n  }\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"intersection\":\n      return \"move\";\n    case \"vertical\":\n      return \"ns-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (styleElement !== null) {\n    document.head.removeChild(styleElement);\n    currentCursorStyle = null;\n    styleElement = null;\n    prevRuleIndex = -1;\n  }\n}\nfunction setGlobalCursorStyle(state, constraintFlags, isPointerDown) {\n  var _styleElement$sheet$i, _styleElement$sheet2;\n  if (!enabled) {\n    return;\n  }\n  const style = getCursorStyle(state, constraintFlags, isPointerDown);\n  if (currentCursorStyle === style) {\n    return;\n  }\n  currentCursorStyle = style;\n  if (styleElement === null) {\n    styleElement = document.createElement(\"style\");\n    const nonce = getNonce();\n    if (nonce) {\n      styleElement.setAttribute(\"nonce\", nonce);\n    }\n    document.head.appendChild(styleElement);\n  }\n  if (prevRuleIndex >= 0) {\n    var _styleElement$sheet;\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\n  }\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isPointerEvent(event) {\n  return event.type.startsWith(\"pointer\");\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\n\nfunction getResizeEventCoordinates(event) {\n  if (isPointerEvent(event)) {\n    if (event.isPrimary) {\n      return {\n        x: event.clientX,\n        y: event.clientY\n      };\n    }\n  } else if (isMouseEvent(event)) {\n    return {\n      x: event.clientX,\n      y: event.clientY\n    };\n  }\n  return {\n    x: Infinity,\n    y: Infinity\n  };\n}\n\nfunction getInputType() {\n  if (typeof matchMedia === \"function\") {\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\n  }\n}\n\nfunction intersects(rectOne, rectTwo, strict) {\n  if (strict) {\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\n  } else {\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\n  }\n}\n\n// Forked from NPM stacking-order@2.0.0\n\n/**\n * Determine which of two nodes appears in front of the other —\n * if `a` is in front, returns 1, otherwise returns -1\n * @param {HTMLElement | SVGElement} a\n * @param {HTMLElement | SVGElement} b\n */\nfunction compare(a, b) {\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\n  const ancestors = {\n    a: get_ancestors(a),\n    b: get_ancestors(b)\n  };\n  let common_ancestor;\n\n  // remove shared ancestors\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\n    a = ancestors.a.pop();\n    b = ancestors.b.pop();\n    common_ancestor = a;\n  }\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\n  const z_indexes = {\n    a: get_z_index(find_stacking_context(ancestors.a)),\n    b: get_z_index(find_stacking_context(ancestors.b))\n  };\n  if (z_indexes.a === z_indexes.b) {\n    const children = common_ancestor.childNodes;\n    const furthest_ancestors = {\n      a: ancestors.a.at(-1),\n      b: ancestors.b.at(-1)\n    };\n    let i = children.length;\n    while (i--) {\n      const child = children[i];\n      if (child === furthest_ancestors.a) return 1;\n      if (child === furthest_ancestors.b) return -1;\n    }\n  }\n  return Math.sign(z_indexes.a - z_indexes.b);\n}\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\n\n/** @param {HTMLElement | SVGElement} node */\nfunction is_flex_item(node) {\n  var _get_parent;\n  // @ts-ignore\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\n  return display === \"flex\" || display === \"inline-flex\";\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction creates_stacking_context(node) {\n  const style = getComputedStyle(node);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\n  if (style.position === \"fixed\") return true;\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\n  // if (\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\n  //   is_flex_item(node)\n  // )\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\n  if (+style.opacity < 1) return true;\n  if (\"transform\" in style && style.transform !== \"none\") return true;\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\n  if (\"filter\" in style && style.filter !== \"none\") return true;\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\n  if (props.test(style.willChange)) return true;\n  // @ts-expect-error\n  if (style.webkitOverflowScrolling === \"touch\") return true;\n  return false;\n}\n\n/** @param {(HTMLElement| SVGElement)[]} nodes */\nfunction find_stacking_context(nodes) {\n  let i = nodes.length;\n  while (i--) {\n    const node = nodes[i];\n    assert(node, \"Missing node\");\n    if (creates_stacking_context(node)) return node;\n  }\n  return null;\n}\n\n/** @param {HTMLElement | SVGElement} node */\nfunction get_z_index(node) {\n  return node && Number(getComputedStyle(node).zIndex) || 0;\n}\n\n/** @param {HTMLElement} node */\nfunction get_ancestors(node) {\n  const ancestors = [];\n  while (node) {\n    ancestors.push(node);\n    // @ts-ignore\n    node = get_parent(node);\n  }\n  return ancestors; // [ node, ... <body>, <html>, document ]\n}\n\n/** @param {HTMLElement} node */\nfunction get_parent(node) {\n  const {\n    parentNode\n  } = node;\n  if (parentNode && parentNode instanceof ShadowRoot) {\n    return parentNode.host;\n  }\n  return parentNode;\n}\n\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\nconst isCoarsePointer = getInputType() === \"coarse\";\nlet intersectingHandles = [];\nlet isPointerDown = false;\nlet ownerDocumentCounts = new Map();\nlet panelConstraintFlags = new Map();\nconst registeredResizeHandlers = new Set();\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\n  var _ownerDocumentCounts$;\n  const {\n    ownerDocument\n  } = element;\n  const data = {\n    direction,\n    element,\n    hitAreaMargins,\n    setResizeHandlerState\n  };\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\n  ownerDocumentCounts.set(ownerDocument, count + 1);\n  registeredResizeHandlers.add(data);\n  updateListeners();\n  return function unregisterResizeHandle() {\n    var _ownerDocumentCounts$2;\n    panelConstraintFlags.delete(resizeHandleId);\n    registeredResizeHandlers.delete(data);\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\n    ownerDocumentCounts.set(ownerDocument, count - 1);\n    updateListeners();\n    if (count === 1) {\n      ownerDocumentCounts.delete(ownerDocument);\n    }\n\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\n    // update the global pointer to account for the change\n    if (intersectingHandles.includes(data)) {\n      const index = intersectingHandles.indexOf(data);\n      if (index >= 0) {\n        intersectingHandles.splice(index, 1);\n      }\n      updateCursor();\n\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\n      // See github.com/bvaughn/react-resizable-panels/issues/402\n      setResizeHandlerState(\"up\", true, null);\n    }\n  };\n}\nfunction handlePointerDown(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  isPointerDown = true;\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateListeners();\n  if (intersectingHandles.length > 0) {\n    updateResizeHandlerStates(\"down\", event);\n\n    // Update cursor based on return value(s) from active handles\n    updateCursor();\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n}\nfunction handlePointerMove(event) {\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n\n  // Edge case (see #340)\n  // Detect when the pointer has been released outside an iframe on a different domain\n  if (isPointerDown &&\n  // Skip this check for \"pointerleave\" events, else Firefox triggers a false positive (see #514)\n  event.type !== \"pointerleave\" && event.buttons === 0) {\n    isPointerDown = false;\n    updateResizeHandlerStates(\"up\", event);\n  }\n  if (!isPointerDown) {\n    const {\n      target\n    } = event;\n\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\n    // at that point, the handles may not move with the pointer (depending on constraints)\n    // but the same set of active handles should be locked until the pointer is released\n    recalculateIntersectingHandles({\n      target,\n      x,\n      y\n    });\n  }\n  updateResizeHandlerStates(\"move\", event);\n\n  // Update cursor based on return value(s) from active handles\n  updateCursor();\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n  }\n}\nfunction handlePointerUp(event) {\n  const {\n    target\n  } = event;\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  panelConstraintFlags.clear();\n  isPointerDown = false;\n  if (intersectingHandles.length > 0) {\n    event.preventDefault();\n    if (!isWithinResizeHandle(target)) {\n      event.stopImmediatePropagation();\n    }\n  }\n  updateResizeHandlerStates(\"up\", event);\n  recalculateIntersectingHandles({\n    target,\n    x,\n    y\n  });\n  updateCursor();\n  updateListeners();\n}\nfunction isWithinResizeHandle(element) {\n  let currentElement = element;\n  while (currentElement) {\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\n      return true;\n    }\n    currentElement = currentElement.parentElement;\n  }\n  return false;\n}\nfunction recalculateIntersectingHandles({\n  target,\n  x,\n  y\n}) {\n  intersectingHandles.splice(0);\n  let targetElement = null;\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\n    targetElement = target;\n  }\n  registeredResizeHandlers.forEach(data => {\n    const {\n      element: dragHandleElement,\n      hitAreaMargins\n    } = data;\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\n    const {\n      bottom,\n      left,\n      right,\n      top\n    } = dragHandleRect;\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\n    if (eventIntersects) {\n      // TRICKY\n      // We listen for pointers events at the root in order to support hit area margins\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\n      // and the element that was actually clicked/touched\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\n      // Calculating stacking order has a cost, so we should avoid it if possible\n      // That is why we only check potentially intersecting handles,\n      // and why we skip if the event target is within the handle's DOM\n      compare(targetElement, dragHandleElement) > 0) {\n        // If the target is above the drag handle, then we also need to confirm they overlap\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\n        //\n        // It's not enough to compare only the target\n        // The target might be a small element inside of a larger container\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\n        let currentElement = targetElement;\n        let didIntersect = false;\n        while (currentElement) {\n          if (currentElement.contains(dragHandleElement)) {\n            break;\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\n            didIntersect = true;\n            break;\n          }\n          currentElement = currentElement.parentElement;\n        }\n        if (didIntersect) {\n          return;\n        }\n      }\n      intersectingHandles.push(data);\n    }\n  });\n}\nfunction reportConstraintsViolation(resizeHandleId, flag) {\n  panelConstraintFlags.set(resizeHandleId, flag);\n}\nfunction updateCursor() {\n  let intersectsHorizontal = false;\n  let intersectsVertical = false;\n  intersectingHandles.forEach(data => {\n    const {\n      direction\n    } = data;\n    if (direction === \"horizontal\") {\n      intersectsHorizontal = true;\n    } else {\n      intersectsVertical = true;\n    }\n  });\n  let constraintFlags = 0;\n  panelConstraintFlags.forEach(flag => {\n    constraintFlags |= flag;\n  });\n  if (intersectsHorizontal && intersectsVertical) {\n    setGlobalCursorStyle(\"intersection\", constraintFlags, isPointerDown);\n  } else if (intersectsHorizontal) {\n    setGlobalCursorStyle(\"horizontal\", constraintFlags, isPointerDown);\n  } else if (intersectsVertical) {\n    setGlobalCursorStyle(\"vertical\", constraintFlags, isPointerDown);\n  } else {\n    resetGlobalCursorStyle();\n  }\n}\nlet listenersAbortController;\nfunction updateListeners() {\n  var _listenersAbortContro;\n  (_listenersAbortContro = listenersAbortController) === null || _listenersAbortContro === void 0 ? void 0 : _listenersAbortContro.abort();\n  listenersAbortController = new AbortController();\n  const options = {\n    capture: true,\n    signal: listenersAbortController.signal\n  };\n  if (!registeredResizeHandlers.size) {\n    return;\n  }\n  if (isPointerDown) {\n    if (intersectingHandles.length > 0) {\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\n        const {\n          body\n        } = ownerDocument;\n        if (count > 0) {\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\n        }\n      });\n    }\n    ownerDocumentCounts.forEach((_, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      body.addEventListener(\"pointerup\", handlePointerUp, options);\n      body.addEventListener(\"pointercancel\", handlePointerUp, options);\n    });\n  } else {\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\n      const {\n        body\n      } = ownerDocument;\n      if (count > 0) {\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\n      }\n    });\n  }\n}\nfunction updateResizeHandlerStates(action, event) {\n  registeredResizeHandlers.forEach(data => {\n    const {\n      setResizeHandlerState\n    } = data;\n    const isActive = intersectingHandles.includes(data);\n    setResizeHandlerState(action, isActive, event);\n  });\n}\n\nfunction useForceUpdate() {\n  const [_, setCount] = useState(0);\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\n}\n\nfunction assert(expectedCondition, message) {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\n    return 0;\n  } else {\n    return actual > expected ? 1 : -1;\n  }\n}\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\n  if (actual.length !== expected.length) {\n    return false;\n  }\n  for (let index = 0; index < actual.length; index++) {\n    const actualSize = actual[index];\n    const expectedSize = expected[index];\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  panelConstraints: panelConstraintsArray,\n  panelIndex,\n  size\n}) {\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\n  let {\n    collapsedSize = 0,\n    collapsible,\n    maxSize = 100,\n    minSize = 0\n  } = panelConstraints;\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\n    if (collapsible) {\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n      const halfwayPoint = (collapsedSize + minSize) / 2;\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n        size = collapsedSize;\n      } else {\n        size = minSize;\n      }\n    } else {\n      size = minSize;\n    }\n  }\n  size = Math.min(maxSize, size);\n  size = parseFloat(size.toFixed(PRECISION));\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  initialLayout,\n  panelConstraints: panelConstraintsArray,\n  pivotIndices,\n  prevLayout,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return initialLayout;\n  }\n  const nextLayout = [...initialLayout];\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\n  let deltaApplied = 0;\n\n  // const DEBUG = [];\n  // DEBUG.push(`adjustLayoutByDelta()`);\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\n  // DEBUG.push(`  delta: ${delta}`);\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  // DEBUG.push(`  trigger: ${trigger}`);\n  // DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 1: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\n            const localDelta = minSize - prevSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\n        const panelConstraints = panelConstraintsArray[index];\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\n        const {\n          collapsedSize = 0,\n          collapsible,\n          minSize = 0\n        } = panelConstraints;\n\n        // DEBUG.push(`edge case check 2: ${index}`);\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\n        if (collapsible) {\n          const prevSize = initialLayout[index];\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\n            const localDelta = prevSize - collapsedSize;\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              // DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too–\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    let maxAvailableDelta = 0;\n\n    // DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const maxSafeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraintsArray.length) {\n        break;\n      }\n    }\n\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\n    // DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraintsArray.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = initialLayout[index];\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        panelConstraints: panelConstraintsArray,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toFixed(3).localeCompare(Math.abs(delta).toFixed(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n    const prevSize = initialLayout[pivotIndex];\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\n    const unsafeSize = prevSize + deltaApplied;\n    const safeSize = resizePanel({\n      panelConstraints: panelConstraintsArray,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraintsArray.length) {\n        const prevSize = nextLayout[index];\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          panelConstraints: panelConstraintsArray,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  // DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  // DEBUG.push(`total size: ${totalSize}`);\n\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\n  // In that case, fall back to our most recent valid layout\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\n    // console.log(DEBUG.join(\"\\n\"));\n\n    return prevLayout;\n  }\n\n  // console.log(DEBUG.join(\"\\n\"));\n  return nextLayout;\n}\n\nfunction calculateAriaValues({\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n  const firstIndex = pivotIndices[0];\n  assert(firstIndex != null, \"No pivot index found\");\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSize = 100,\n      minSize = 0\n    } = constraints;\n    if (index === firstIndex) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[firstIndex];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction isHTMLElement(target) {\n  if (target instanceof HTMLElement) {\n    return true;\n  }\n\n  // Fallback to duck typing to handle edge case of portals within a popup window\n  return typeof target === \"object\" && target !== null && \"tagName\" in target && \"getAttribute\" in target;\n}\n\nfunction getPanelGroupElement(id, rootElement = document) {\n  // If the root element is the PanelGroup\n  if (isHTMLElement(rootElement) && rootElement.dataset.panelGroupId == id) {\n    return rootElement;\n  }\n\n  // Else query children\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandleElement(id, scope = document) {\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId, scope);\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  panelGroupElement,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        const panelData = panelDataArray[index];\n        assert(panelData, `No panel data found for index \"${index}\"`);\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\n  useEffect(() => {\n    if (!panelGroupElement) {\n      return;\n    }\n    const eagerValues = eagerValuesRef.current;\n    assert(eagerValues, `Eager values not found`);\n    const {\n      panelDataArray\n    } = eagerValues;\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\n      assert(handleId, `Resize handle element has no handle id attribute`);\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                assert(panelData, `No panel data found for index ${index}`);\n                const size = layout[index];\n                const {\n                  collapsedSize = 0,\n                  collapsible,\n                  minSize = 0\n                } = panelData.constraints;\n                if (size != null && collapsible) {\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    initialLayout: layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\n                    prevLayout: layout,\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  const {\n    x,\n    y\n  } = getResizeEventCoordinates(event);\n  return isHorizontal ? x : y;\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n  assert(groupId, `Resize handle element has no group id attribute`);\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeBy != null) {\n      delta = keyboardResizeBy;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    if (initialDragState == null) {\n      return 0;\n    }\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSize;\n      remainingSize -= defaultSize;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const panelConstraints = panelConstraintsArray[index];\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\n    const {\n      defaultSize\n    } = panelConstraints;\n    if (defaultSize != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\n  layout.forEach((size, index) => {\n    const panelData = panelsArray[index];\n    assert(panelData, `Panel data not found for index ${index}`);\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsedSize = 0,\n      collapsible\n    } = constraints;\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\n      panelIdToLastNotifiedSizeMap[panelId] = size;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(size, lastNotifiedSize);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  defaultSize,\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (size == null) {\n    // Initial render (before panels have registered themselves)\n    // In order to support server rendering, fall back to default size if provided\n    flexGrow = defaultSize != undefined ? defaultSize.toFixed(precision) : \"1\";\n  } else if (panelData.length === 1) {\n    // Special case: Single panel group should always fill full width/height\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toFixed(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\nfunction getPanelGroupKey(autoSaveId) {\n  return `react-resizable-panels:${autoSaveId}`;\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getPanelKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\n    const serialized = storage.getItem(panelGroupKey);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\n  var _loadSerializedPanelG, _state$panelKey;\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\n  const panelKey = getPanelKey(panels);\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\n}\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\n  var _loadSerializedPanelG2;\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\n  const panelKey = getPanelKey(panels);\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\n  state[panelKey] = {\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\n    layout: sizes\n  };\n  try {\n    storage.setItem(panelGroupKey, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const unsafeSize = nextLayout[index];\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\n    const safeSize = resizePanel({\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      assert(prevSize != null, `No layout data found for index ${index}`);\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  direction,\n  forwardedRef,\n  id: idFromProps = null,\n  onLayout = null,\n  keyboardResizeBy = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const panelGroupElementRef = useRef(null);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const forceUpdate = useForceUpdate();\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeBy,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: [],\n    panelDataArrayChanged: false\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        layout\n      } = eagerValuesRef.current;\n      return layout;\n    },\n    setLayout: unsafeLayout => {\n      const {\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const safeLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout);\n        }\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n  });\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n    panelGroupElement: panelGroupElementRef.current\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n      let debouncedSave = debounceMap[autoSaveId];\n\n      // Limit the frequency of localStorage updates.\n      if (debouncedSave == null) {\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n        debounceMap[autoSaveId] = debouncedSave;\n      }\n\n      // Clone mutable data before passing to the debounced function,\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\n      const clonedPanelDataArray = [...panelDataArray];\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSize = 0,\n        panelSize = 0,\n        minSize: minSizeFromProps = 0,\n        pivotIndices\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          initialLayout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          prevLayout,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout);\n          }\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n        }\n      }\n    }\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return panelSize;\n  }, []);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n    return computePanelFlexBoxStyle({\n      defaultSize,\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize = 0,\n      collapsible,\n      panelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\n  }, []);\n  const registerPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n    eagerValuesRef.current.panelDataArrayChanged = true;\n    forceUpdate();\n  }, [forceUpdate]);\n\n  // (Re)calculate group layout whenever panels are registered or unregistered.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsomorphicLayoutEffect(() => {\n    if (eagerValuesRef.current.panelDataArrayChanged) {\n      eagerValuesRef.current.panelDataArrayChanged = false;\n      const {\n        autoSaveId,\n        onLayout,\n        storage\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n\n      // If this panel has been configured to persist sizing information,\n      // default size should be restored from local storage if possible.\n      let unsafeLayout = null;\n      if (autoSaveId) {\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\n        if (state) {\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\n          unsafeLayout = state.layout;\n        }\n      }\n      if (unsafeLayout == null) {\n        unsafeLayout = calculateUnsafeDefaultLayout({\n          panelDataArray\n        });\n      }\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    }\n  });\n\n  // Reset the cached layout if hidden by the Activity/Offscreen API\n  useIsomorphicLayoutEffect(() => {\n    const eagerValues = eagerValuesRef.current;\n    return () => {\n      eagerValues.layout = [];\n    };\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    let isRTL = false;\n    const panelGroupElement = panelGroupElementRef.current;\n    if (panelGroupElement) {\n      const style = window.getComputedStyle(panelGroupElement, null);\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\n        isRTL = true;\n      }\n    }\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const panelGroupElement = panelGroupElementRef.current;\n      if (!panelGroupElement) {\n        return () => null;\n      }\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeBy,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\n      const isHorizontal = direction === \"horizontal\";\n      if (isHorizontal && isRTL) {\n        delta = -delta;\n      }\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        prevLayout,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isPointerEvent(event) || isMouseEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change–\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged && delta !== 0) {\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\n            // This mimics VS Code behavior.\n            if (isHorizontal) {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\n            } else {\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\n            }\n          } else {\n            reportConstraintsViolation(dragHandleId, 0);\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout);\n        }\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      panelSize,\n      pivotIndices\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      initialLayout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      prevLayout,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout);\n      }\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\n    }\n  }, []);\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSize: prevCollapsedSize = 0,\n      collapsible: prevCollapsible\n    } = prevConstraints;\n    const {\n      collapsedSize: nextCollapsedSize = 0,\n      collapsible: nextCollapsible,\n      maxSize: nextMaxSize = 100,\n      minSize: nextMinSize = 0\n    } = panelData.constraints;\n    const {\n      panelSize: prevPanelSize\n    } = panelDataHelper(panelDataArray, panelData, layout);\n    if (prevPanelSize == null) {\n      // It's possible that the panels in this group have changed since the last render\n      return;\n    }\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\n        resizePanel(panelData, nextCollapsedSize);\n      }\n    } else if (prevPanelSize < nextMinSize) {\n      resizePanel(panelData, nextMinSize);\n    } else if (prevPanelSize > nextMaxSize) {\n      resizePanel(panelData, nextMaxSize);\n    }\n  }, [resizePanel]);\n\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    if (!panelGroupElementRef.current) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    setDragState(null);\n  }, []);\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = findPanelDataIndex(panelDataArray, panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n\n      // TRICKY\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\n      eagerValuesRef.current.panelDataArrayChanged = true;\n      forceUpdate();\n    }\n  }, [forceUpdate]);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    reevaluatePanelConstraints,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel,\n    panelGroupElement: panelGroupElementRef.current\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    ref: panelGroupElementRef,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    // CSS selectors\n    [DATA_ATTRIBUTES.group]: \"\",\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction findPanelDataIndex(panelDataArray, panelData) {\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\n}\nfunction panelDataHelper(panelDataArray, panelData, layout) {\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSize = layout[panelIndex];\n  return {\n    ...panelData.constraints,\n    panelSize,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n  panelGroupElement\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\n            assert(groupId, `No group element found for id \"${groupId}\"`);\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  disabled = false,\n  hitAreaMargins,\n  id: idFromProps,\n  onBlur,\n  onClick,\n  onDragging,\n  onFocus,\n  onPointerDown,\n  onPointerUp,\n  style: styleFromProps = {},\n  tabIndex = 0,\n  tagName: Type = \"div\",\n  ...rest\n}) {\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\n  const elementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onClick,\n    onDragging,\n    onPointerDown,\n    onPointerUp\n  });\n  useEffect(() => {\n    callbacksRef.current.onClick = onClick;\n    callbacksRef.current.onDragging = onDragging;\n    callbacksRef.current.onPointerDown = onPointerDown;\n    callbacksRef.current.onPointerUp = onPointerUp;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    groupId,\n    registerResizeHandle: registerResizeHandleWithParentGroup,\n    startDragging,\n    stopDragging,\n    panelGroupElement\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const [state, setState] = useState(\"inactive\");\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const committedValuesRef = useRef({\n    state\n  });\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.state = state;\n  });\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\n\n  // Extract hit area margins before passing them to the effect's dependency array\n  // so that inline object values won't trigger re-renders\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const element = elementRef.current;\n    assert(element, \"Element ref not attached\");\n    let didMove = false;\n    const setResizeHandlerState = (action, isActive, event) => {\n      if (!isActive) {\n        setState(\"inactive\");\n        return;\n      }\n      switch (action) {\n        case \"down\":\n          {\n            setState(\"drag\");\n            didMove = false;\n            assert(event, 'Expected event to be defined for \"down\" action');\n            startDragging(resizeHandleId, event);\n            const {\n              onDragging,\n              onPointerDown\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\n            break;\n          }\n        case \"move\":\n          {\n            const {\n              state\n            } = committedValuesRef.current;\n            didMove = true;\n            if (state !== \"drag\") {\n              setState(\"hover\");\n            }\n            assert(event, 'Expected event to be defined for \"move\" action');\n            resizeHandler(event);\n            break;\n          }\n        case \"up\":\n          {\n            setState(\"hover\");\n            stopDragging();\n            const {\n              onClick,\n              onDragging,\n              onPointerUp\n            } = callbacksRef.current;\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\n            if (!didMove) {\n              onClick === null || onClick === void 0 ? void 0 : onClick();\n            }\n            break;\n          }\n      }\n    };\n    return registerResizeHandle(resizeHandleId, element, direction, {\n      coarse: coarseHitAreaMargins,\n      fine: fineHitAreaMargins\n    }, setResizeHandlerState);\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n    panelGroupElement\n  });\n  const style = {\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    ...rest,\n    children,\n    className: classNameFromProps,\n    id: idFromProps,\n    onBlur: () => {\n      setIsFocused(false);\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\n    },\n    onFocus: () => {\n      setIsFocused(true);\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\n    },\n    ref: elementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex,\n    // CSS selectors\n    [DATA_ATTRIBUTES.groupDirection]: direction,\n    [DATA_ATTRIBUTES.groupId]: groupId,\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\n    [DATA_ATTRIBUTES.resizeHandleState]: state\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nfunction usePanelGroupContext() {\n  const context = useContext(PanelGroupContext);\n  return {\n    direction: context === null || context === void 0 ? void 0 : context.direction,\n    groupId: context === null || context === void 0 ? void 0 : context.groupId\n  };\n}\n\nfunction getPanelElement(id, scope = document) {\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getPanelElementsForGroup(groupId, scope = document) {\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\n  if (!intersects(rectOne, rectTwo, strict)) {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  }\n  return {\n    x: Math.max(rectOne.x, rectTwo.x),\n    y: Math.max(rectOne.y, rectTwo.y),\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\n  };\n}\n\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, customizeGlobalCursorStyles, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce, usePanelGroupContext };\n","import PropTypes from 'prop-types';\nimport { Panel as ReactPanel } from 'react-resizable-panels';\n\nconst Panel = (props) => {\n    const { children, setProps, ...other } = props;\n\n    return (\n        <ReactPanel {...other}>\n            {children}\n        </ReactPanel>\n    );\n}\n\nPanel.defaultProps = {};\n\nPanel.propTypes = {\n    /**\n     * The ID used to identify this component in Dash callbacks.\n     */\n    id: PropTypes.string,\n\n    /**\n     * The children of this component.\n     */\n    children: PropTypes.node,\n\n    /**\n     * Update the component's props.\n     */\n    setProps: PropTypes.func,\n\n    /**\n     * The class name for the panel group used for styling\n    */\n    className: PropTypes.string,\n\n\n    /**\n     * Panel should collapse to this size (in percentage or pixels)\n    */\n    collapsedSize: PropTypes.number,\n\n    /**\n     * Whether Panel should collapse when resized beyond its minSize\n    */\n    collapsible: PropTypes.bool,\n\n    /**\n     * Initial size of panel (in percentage)\n    */\n    defaultSize: PropTypes.number,\n\n\n    /**\n     * Minimum size of panel (in percentage)\n    */\n    minSize: PropTypes.number,\n\n    /**\n     * Maximum size of panel (in percentage)\n    */\n    maxSize: PropTypes.number,\n\n    /**\n     * Order of panel within group; required for groups with conditionally rendered panels\n    */\n    order: PropTypes.number,\n\n    /**\n     * style for the panel group\n    */\n    style: PropTypes.object,\n};\n\nexport default Panel;","import PropTypes from 'prop-types';\nimport { PanelGroup as ReactPanelGroup } from 'react-resizable-panels';\n\nconst PanelGroup = (props) => {\n    const { children, setProps, ...other } = props;\n\n    return (\n        <ReactPanelGroup {...other}>\n            {children}\n        </ReactPanelGroup>\n    );\n}\n\nPanelGroup.defaultProps = {};\n\nPanelGroup.propTypes = {\n    /**\n     * The ID used to identify this component in Dash callbacks.\n     */\n    id: PropTypes.string,\n\n    /**\n     * The children of this component.\n     */\n    children: PropTypes.node,\n\n    /**\n     * Updates the component's props.\n     */\n    setProps: PropTypes.func,\n\n    /**\n     * Unique id used to auto-save group arragement via local storage.\n    */\n    autoSaveId: PropTypes.string,\n\n    /**\n     * The class name for the panel group for styling\n    */\n    className: PropTypes.string,\n\n    /**\n     * Direction of the panel group - horizontal or vertical\n    */\n    direction: PropTypes.string,\n\n    /**\n     * Additonal style for the panel group\n    */\n    style: PropTypes.object,\n};\n\nexport default PanelGroup;","import PropTypes from 'prop-types';\nimport { PanelResizeHandle as ReactPanelResizeHandle } from 'react-resizable-panels';\n\nconst PanelResizeHandle = (props) => {\n    const { children, setProps, ...other } = props;\n\n    return (\n        <ReactPanelResizeHandle {...other}>\n            {children}\n        </ReactPanelResizeHandle>\n    );\n}\n\nPanelResizeHandle.defaultProps = {};\n\nPanelResizeHandle.propTypes = {\n    /**\n     * The ID used to identify this component in Dash callbacks.\n     */\n    id: PropTypes.string,\n\n    /**\n     * The children of this component.\n     */\n    children: PropTypes.node,\n\n    /**\n     * Updates the component's props.\n     */\n    setProps: PropTypes.func,\n\n    /**\n     * The class name for the panel group for styling\n    */\n    className: PropTypes.string,\n\n    /**\n     * Disable drag handle\n    */\n    disable: PropTypes.bool,\n\n    /**\n     * Additional style for the panel group\n    */\n    style: PropTypes.object,\n};\n\nexport default PanelResizeHandle;"],"names":["leafPrototypes","getProto","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","n","getter","__esModule","d","a","Object","getPrototypeOf","obj","t","value","mode","this","then","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","definition","o","defineProperty","enumerable","get","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","url","getCurrentScript","script","document","currentScript","doc_scripts","getElementsByTagName","scripts","i","length","push","filter","s","async","text","textContent","slice","src","split","join","jsonpScriptSrc","__jsonpScriptSrc__","chunkId","isLocal","test","srcFragments","fileFragments","splice","window","PanelGroupContext","createContext","displayName","DATA_ATTRIBUTES","useIsomorphicLayoutEffect","useLayoutEffect","useId","toString","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","useRef","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSize","collapsible","defaultSize","forwardedRef","id","idFromProps","maxSize","minSize","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","rest","context","useContext","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","reevaluatePanelConstraints","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","idIsFromProps","didLogMissingDefaultSizeWarning","prevConstraints","panelData","useImperativeHandle","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","size","createElement","parseFloat","flexGrow","toFixed","forwardRef","props","ref","currentCursorStyle","prevRuleIndex","styleElement","setGlobalCursorStyle","state","constraintFlags","isPointerDown","_styleElement$sheet$i","_styleElement$sheet2","horizontalMin","EXCEEDED_HORIZONTAL_MIN","horizontalMax","EXCEEDED_HORIZONTAL_MAX","verticalMin","EXCEEDED_VERTICAL_MIN","verticalMax","EXCEEDED_VERTICAL_MAX","getCursorStyle","nonce","getNonce","setAttribute","head","appendChild","_styleElement$sheet","sheet","removeRule","insertRule","isKeyDown","event","type","isPointerEvent","startsWith","isMouseEvent","getResizeEventCoordinates","isPrimary","x","clientX","y","clientY","Infinity","intersects","rectOne","rectTwo","strict","width","height","creates_stacking_context","node","getComputedStyle","position","zIndex","_get_parent","display","get_parent","is_flex_item","opacity","transform","webkitTransform","mixBlendMode","webkitFilter","isolation","willChange","webkitOverflowScrolling","find_stacking_context","nodes","assert","get_z_index","Number","get_ancestors","ancestors","parentNode","ShadowRoot","host","isCoarsePointer","matchMedia","matches","getInputType","intersectingHandles","ownerDocumentCounts","Map","panelConstraintFlags","registeredResizeHandlers","Set","handlePointerDown","target","recalculateIntersectingHandles","updateListeners","updateResizeHandlerStates","updateCursor","preventDefault","isWithinResizeHandle","stopImmediatePropagation","handlePointerMove","buttons","handlePointerUp","clear","element","currentElement","hasAttribute","parentElement","targetElement","HTMLElement","SVGElement","data","dragHandleElement","hitAreaMargins","dragHandleRect","getBoundingClientRect","bottom","left","right","top","margin","coarse","fine","contains","b","common_ancestor","at","pop","z_indexes","childNodes","furthest_ancestors","child","Math","sign","compare","didIntersect","intersectsHorizontal","intersectsVertical","direction","flag","removeChild","listenersAbortController","_listenersAbortContro","abort","AbortController","options","capture","signal","count","ownerDocument","body","addEventListener","_","action","setResizeHandlerState","isActive","includes","expectedCondition","message","console","error","fuzzyCompareNumbers","actual","expected","fractionDigits","fuzzyNumbersEqual$1","fuzzyNumbersEqual","panelConstraints","panelConstraintsArray","panelIndex","min","adjustLayoutByDelta","delta","initialLayout","pivotIndices","prevLayout","trigger","nextLayout","firstPivotIndex","secondPivotIndex","deltaApplied","index","prevSize","localDelta","abs","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","safeSize","localeCompare","numeric","fuzzyLayoutsEqual","pivotIndex","unsafeSize","reduce","total","calculateAriaValues","layout","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","firstIndex","valueMax","valueMin","max","valueNow","getResizeHandleElementsForGroup","scope","Array","from","querySelectorAll","getResizeHandleElementIndex","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","panelGroupElement","getPanelGroupElement","rootElement","dataset","panelGroupId","querySelector","getResizeHandleElement","areEqual","arrayA","arrayB","getResizeEventCursorPosition","isHorizontal","callPanelCallbacks","panelIdToLastNotifiedSizeMap","lastNotifiedSize","compareLayouts","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","getPanelGroupKey","autoSaveId","getPanelKey","panels","map","panel","JSON","stringify","sort","loadSerializedPanelGroupState","storage","panelGroupKey","serialized","parsed","parse","savePanelGroupState","panelSizesBeforeCollapse","sizes","_loadSerializedPanelG2","panelKey","expandToSizes","fromEntries","entries","validatePanelGroupLayout","nextLayoutTotalSize","accumulated","remainingSize","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","keyboardResizeBy","panelGroupElementRef","dragState","setDragState","useState","setLayout","forceUpdate","setCount","useCallback","prevCount","useForceUpdate","panelIdToLastNotifiedSizeMapRef","panelSizeBeforeCollapseRef","prevDeltaRef","committedValuesRef","eagerValuesRef","panelDataArray","panelDataArrayChanged","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","safeLayout","didWarnAboutMissingResizeHandle","resizeHandleElements","resizeHandleElement","round","removeAttribute","useEffect","eagerValues","handles","cleanupFunctions","handleId","idBefore","idAfter","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","getResizeHandlePanelIds","onKeyDown","defaultPrevented","removeEventListener","cleanupFunction","useWindowSplitterPanelGroupBehavior","debouncedSave","callback","durationMs","timeoutId","args","clearTimeout","setTimeout","debounce","clonedPanelDataArray","clonedPanelSizesBeforeCollapse","panelSize","panelDataHelper","set","findPanelDataIndex","minSizeOverride","minSizeFromProps","prevPanelSize","baseSize","precision","flexBasis","flexShrink","overflow","pointerEvents","computePanelFlexBoxStyle","isPanelExpanded","panelA","panelB","orderA","orderB","_loadSerializedPanelG","_state$panelKey","loadPanelGroupState","numPanelsWithSizes","calculateUnsafeDefaultLayout","registerResizeHandle","isRTL","getPropertyValue","initialDragState","shiftKey","movement","handleElement","initialCursorPosition","cursorPosition","groupElement","groupRect","calculateDragOffsetPercentage","calculateDeltaPercentage","layoutChanged","resizeHandleId","unsafePanelSize","prevCollapsedSize","prevCollapsible","nextCollapsedSize","nextCollapsible","nextMaxSize","nextMinSize","startDragging","stopDragging","useMemo","flexDirection","Provider","prevPanelData","disabled","onBlur","onClick","onDragging","onFocus","onPointerDown","onPointerUp","tabIndex","_hitAreaMargins$coars","_hitAreaMargins$fine","elementRef","callbacksRef","panelGroupContext","registerResizeHandleWithParentGroup","setState","isFocused","setIsFocused","resizeHandler","setResizeHandler","coarseHitAreaMargins","fineHitAreaMargins","didMove","_ownerDocumentCounts$","add","_ownerDocumentCounts$2","delete","focus","useWindowSplitterResizeHandlerBehavior","role","touchAction","userSelect","Panel","other","setProps","_objectWithoutProperties","_excluded","React","ReactPanel","defaultProps","propTypes","PropTypes","PanelGroup","ReactPanelGroup","PanelResizeHandle","ReactPanelResizeHandle","disable"],"sourceRoot":""}